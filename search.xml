<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多种继承方式</title>
      <link href="post/ckh309b8c00012stl37ile240/"/>
      <url>post/ckh309b8c00012stl37ile240/</url>
      
        <content type="html"><![CDATA[<p>这是一篇笔记的笔记，偶然间在 github 发现了 <a href="https://github.com/mqyqingfeng/Blog">这个 repo</a>，其中深入系列还是不错的，至少讲的比较明白，适合我这样的孩子。把之前自己不太清楚的地方搞搞清楚。</p><p>本篇主要是整理一下多种继承方式，面试的时候总问到继承。在看继承之前还是推荐把原型和原型链搞搞清楚，不然看着有点晕。</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>最基本的继承，也是比较好理解的。宗旨就是 Child 的原型指向 Parent 的实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi~'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// parent</span>c<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Hi~</span></code></pre><p>这种继承方式会有两个很严重的问题：</p><ul><li>引用类型的值会被共享</li><li>在创建 Child 的实例（也就是 <code>new Child</code>）的时候不能向 Parent 传值</li></ul><p>我们先看第一个问题，注意说的是<strong>引用类型</strong>的值。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token string">'green'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'golden'</span>c<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// golden</span>c1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// golden</span></code></pre><p>按常理来说每一个实例应该都是独立的，与其它实例互不干涉，但是在原型链继承中引用值类型是被共用的。顺着我们看第二个问题，就算是 <code>new Child</code> 的时候传值了，怎么给 Parent 是不是个问题。</p><h2 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h2><p>通过 <code>call</code> 或者 <code>apply</code> 把 Parent 放在 Child 里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Eva'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'pink'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true">// Eva</span>c<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ['pink', 'green']</span></code></pre><p>我们来看看有没有解决原型链继承的两个问题：引用类型值被共享；不能传参。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Eva'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'pink'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'blue'</span>c<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ["blue", "green"]</span>c1<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ["pink", "green"]</span></code></pre><p>看来共享的问题解决了，保证了每个 Child 实例都是独立的。</p><p>传参问题也是 OK 的，毕竟 <code>call()</code> 和 <code>apply()</code> 是可以接收参数的，只是接受方式不太一样。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span><span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Eva'</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true">// Alice</span>c1<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// Eva</span></code></pre><p>不过缺点是方法是在构造函数中定义的，导致每次创建实例都会创建一遍方法。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>原型链继承 + 构造函数继承</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I\'m </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构造函数继承</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 原型链继承</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/** * 这里需要注意一个事情 * 当我们将原型指到 Parent 的实例身上，那么 Child 的原型指向的构造函数就变成了 Parent * 这是原型链继承的副作用 * 我们需要指回来 **/</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span>c1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// I'm Alice</span></code></pre><p>这种继承方式的优点在于解决了传参问题和引用类型值的共享问题。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span><span class="token keyword">let</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Bonnie'</span><span class="token punctuation">)</span>c1<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'pink'</span>c1<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ['pink', 'green']</span>c2<span class="token punctuation">.</span>colors <span class="token comment" spellcheck="true">// ['blue', 'green']</span></code></pre><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>将传入的对象作为创建的对象的原型。</p><p>其实特别像是“引擎自动关联一个对象给你”一样，只是这里我们手动关联。</p><p><strong>这也是 <code>Object.create()</code> 的模拟实现</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Bonnie'</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><p>它的问题在于引用类型会被共享</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    colors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Bonnie'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>o1<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'User'</span>o2<span class="token punctuation">.</span>colors <span class="token comment" spellcheck="true">// ['User']</span></code></pre><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>    clone<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi~'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> clone<span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><p>这种继承方式的问题在于</p><ul><li>引用值类型共享</li><li>每次创建都会创建一遍方法，这一点和经典继承一样</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>    clone<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi~'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> clone<span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    colors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Bonnie'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>o1<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'User'</span>o2<span class="token punctuation">.</span>colors <span class="token comment" spellcheck="true">// ['User']</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JS 混淆知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端（3）</title>
      <link href="post/ckh309b8s000l2stla67tbv6j/"/>
      <url>post/ckh309b8s000l2stla67tbv6j/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向对象还是基于对象？</p></blockquote><h2 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h2><h3 id="唯一标识：即使完全相同的两个对象，也并非同一个对象"><a href="#唯一标识：即使完全相同的两个对象，也并非同一个对象" class="headerlink" title="唯一标识：即使完全相同的两个对象，也并非同一个对象"></a>唯一标识：即使完全相同的两个对象，也并非同一个对象</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>a <span class="token operator">==</span> b <span class="token comment" spellcheck="true">// false</span></code></pre><p>对象具有唯一标识的<strong>内存地址</strong>，所以具有唯一标识。</p><h3 id="状态：对象具有状态，同一对象可能处于不同状态"><a href="#状态：对象具有状态，同一对象可能处于不同状态" class="headerlink" title="状态：对象具有状态，同一对象可能处于不同状态"></a>状态：对象具有状态，同一对象可能处于不同状态</h3><p>在 JS 中，将<strong>状态</strong>和<strong>行为</strong>统一抽象为<strong>属性</strong>，所以和第三点行为一起说。</p><h3 id="行为：对象的状态可能因为它的行为产生变迁"><a href="#行为：对象的状态可能因为它的行为产生变迁" class="headerlink" title="行为：对象的状态可能因为它的行为产生变迁"></a>行为：对象的状态可能因为它的行为产生变迁</h3><p>由于 JS 把行为和状态统一抽象为属性，所以属性的方式就可以有数据或函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token string">'Hi~'</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="对象的两类属性"><a href="#对象的两类属性" class="headerlink" title="对象的两类属性"></a>对象的两类属性</h2><p>JS 用一组特征（attribute）来描述属性（property）</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>特征：</p><ul><li>value</li><li>writable：默认为 <code>true</code></li><li>enumerable：默认为 <code>true</code></li><li>configurable：默认为 <code>true</code></li></ul><p>想要查看某一属性的配置的话，可以用到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor(obj, key)</code></a> 查看</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { value: 123, writable: true, enumerable: true, configurable: true }</span></code></pre><p>如果想要更改的话就用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty(obj, key, config)</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token keyword">let</span> config <span class="token operator">=</span> <span class="token punctuation">{</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span></code></pre><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>特征</p><ul><li>getter</li><li>setter</li><li>enumerable</li><li>configurable</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><blockquote><p>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端笔记（2）</title>
      <link href="post/ckh309b8r000k2stl4jtj2cx2/"/>
      <url>post/ckh309b8r000k2stl4jtj2cx2/</url>
      
        <content type="html"><![CDATA[<p>今天主要是讲类型，面试中经常会问到判断类型的问题，所以除了文章中讲到的知识点之外可能还会有一些补充吧。</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>String</li><li>Number</li><li>Symbol</li><li>Object</li></ul><h2 id="Undefined-amp-Null"><a href="#Undefined-amp-Null" class="headerlink" title="Undefined &amp; Null"></a>Undefined &amp; Null</h2><blockquote><p>为什么有的编程规范要求用 void 0 代替 undefined？</p></blockquote><p>我们先来解释一下 <code>void</code> 运算符，该运算符对给定的表达式进行求值，然后返回 <code>undefined</code>。Undefined 表示未定义的，所有变量的初始类型都是 Undefined，该类型只有一个值 <code>undefined</code>。</p><p>这里说 <code>void 0</code> 去代替 <code>undefined</code> 是因为 <code>undefined</code> 不是 JS 中的关键字，他是一个变量，作为变量来说，就有可能被篡改，我可以直接 <code>undefined = 123</code>，也是为了保证在逻辑代码中不要出现这种 *** 问题，有的规范会要求用 <code>void 0</code> 来代替 <code>undefined</code>。</p><p>这里其实有一个常见问题就是如何判断一个值是 <code>undefined</code>，毕竟这孩子是能被篡改的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> ii <span class="token operator">===</span> undefined  <span class="token comment" spellcheck="true">// true</span><span class="token keyword">typeof</span> i <span class="token operator">==</span> <span class="token string">'undefined'</span>  <span class="token comment" spellcheck="true">//true</span></code></pre><p>上面提到了 Undefined ，就一定要说说 Null，这俩孩子就好像是绑在一起的，面试的时候总会问到。</p><p>Null 表示空，而且它是个关键字，不用担心篡改的问题。不过需要注意的是 <code>null == undefined</code> 是 <code>true</code> ，需要用 <code>===</code></p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>注意强制转为会转成 <code>false</code> 的值</p><ul><li><code>false</code></li><li><code>0</code></li><li><code>-0</code></li><li><code>''</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>NaN</code></li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote><p>字符串有最大长度吗？</p></blockquote><p>有最大长度是肯定有的，但是这个长度不是我们平常意义上的多少个字，而是 UTF16 编码长度，最大长度为 <strong>2^53 - 1</strong></p><p>需要注意的是字符串一定构造出来，就没有方法能够变更。这也就是我们更改字符串的时候为什么会先拆再组合。</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 中有几个特例需要注意一下 <code>NaN</code>、<code>+0</code>、<code>-0</code>、<code>Infinity</code>、<code>-Infinity</code>。</p><p><code>-0</code> 在平常工作中也没有太注意过，但是文章中有提到需要留意区分，照例还是安排一下。</p><blockquote><p>另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。</p></blockquote><p>我们回到文章中提到的经典迷惑题</p><blockquote><p>0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？</p></blockquote><p>这里需要把握两个知识点</p><ol><li>在 JS 中，Number 是<strong>双精度浮点数规则</strong>，所以加起来是 0.30000…，浮点数运算的精度问题导致等式左右的结果不想等，差的很小。</li><li>比较方法也有锅，我们不能用 <code>==</code> 或 <code>===</code> 来比较，我们应该比较两者的最小精度是不是小于 JS 提供的最小精度值</li></ol><pre class=" language-javascript"><code class="language-javascript">Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span>EPSILON</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>这是 ES6 中引入的新类型。在 ES5 中对象的 key 都是字符串，这就会导致同名的会有覆盖行为。为了保证每个属性的 key 都是唯一的，ES6 引入了 Symbol，它表示唯一的值。</p><p>由于 Symbol 生成的是原始类型值，不是对象，所以不能用 <code>new</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>a <span class="token operator">==</span> b  <span class="token comment" spellcheck="true">// false</span>a <span class="token operator">===</span> b <span class="token comment" spellcheck="true">// false</span></code></pre><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>这个类型涉及的知识点就比较多了，后面应该会拆开单独讲吧。</p><p>在 JS 中，对象的属性分为<strong>数据属性</strong>和<strong>属性访问器</strong>，对于 key 来说可以是字符串或者 Symbol</p><blockquote><p>为什么给对象添加的方法能用在基本类型上？</p></blockquote><p>答：运算符提供了装箱操作，它会根据基础类型构造一个临时对象，让我们能在基础类型上调用对应的对象方法。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>在文章中还涉及到了类型转换的装箱操作和封箱操作，说实话没怎么看懂，等我搞定了我再来更新！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端笔记(1)</title>
      <link href="post/ckh309b8g00032stl3x513nf3/"/>
      <url>post/ckh309b8g00032stl3x513nf3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/intro/154">《重学前端》</a> 购买了很久，之前也断断续续的看了一些，一直没有很认真的学习。现在终于有时间沉下心来好好看看了。这个系列的笔记和原文对比起来可能有些不一样，因为我会看完一篇，加上自己的理解对整篇文章做一个回顾和总结，所以建议先看完对应的章节再看笔记。</p><h2 id="开篇词-从今天起，重新理解前端"><a href="#开篇词-从今天起，重新理解前端" class="headerlink" title="开篇词 | 从今天起，重新理解前端"></a>开篇词 | 从今天起，重新理解前端</h2><p>本篇首先介绍了前端的发展历史。青铜时期（ajax 出现）→ 白银时期（前端开始有意识的处理数据，保存数据，逐步与后端分离）→ 黄金时代（框架的出现）</p><p>其次介绍了《重学前端》的目的，作者会提供视角帮助读者系统的认识前端知识点，形成自己的知识图谱。将知识从点到面，逐步涵盖理解前端技能点。</p><h2 id="明确你的前端学习路线和方法"><a href="#明确你的前端学习路线和方法" class="headerlink" title="明确你的前端学习路线和方法"></a>明确你的前端学习路线和方法</h2><p>很多人都说前端门槛相当低，但是能一直向上走的人没几个。我个人认为门槛是低，但就是因为低，导致知识点庞大且杂乱。同样的效果通过不同属性都可以达到，但是根本上他们之间还有一定的却别。这让学习成本在不断的增加。前端技术的发展比任何一门语言发展的都快，无论是框架、库还是相关标准，变化之快是你想不到的，这在某种程度上无疑增加了前端工作者的学习成本。</p><p>面对这种「学习」环境，我们能做的就是找到适合自己的学习方法和学习路径。</p><p>winter 在文章中介绍了两种学习方法：<strong>建立知识架构</strong>和<strong>追本溯源</strong></p><h3 id="建立知识架构"><a href="#建立知识架构" class="headerlink" title="建立知识架构"></a>建立知识架构</h3><p>简单说来是就画自己的知识图谱，从父节点一层一层细化自己的子节点。</p><p>前端从大方向来分可以分为：HTML、CSS、JavaScript、浏览器、综合应用</p><p>我们以  JavaScript 为例一层一层细化节点</p><blockquote><p>因为对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程</p></blockquote><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/156d0524.png" alt="JavaScript 顶层分类"></p><h3 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h3><p>简单说就是「翻旧账」，去看论文、去看标准。虽然我觉得标准不是给人看的。</p><h2 id="列一份前端知识架构图"><a href="#列一份前端知识架构图" class="headerlink" title="列一份前端知识架构图"></a>列一份前端知识架构图</h2><p>根据上一篇的介绍，我们尝试的列一份知识图片</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/1ac20555.png" alt="JavaScript 知识架构"></p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/1d1d05a8.png" alt="HTML 知识架构"></p><p>对于 HTML 来说我们最直观的感受就是标签，那就按照标签的属性来划分。这个东西没有对错之分，只要符合划分原则就行。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/4abf7c12.png" alt="CSS 知识架构"></p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/03f35380.png" alt="浏览器知识架构"></p><h3 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/b1326b14.png" alt="前端工程实践"></p><p>对于这部分而言对于团队的意义会更重大一点</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 知识架构 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
