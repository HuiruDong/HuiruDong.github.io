<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重学前端笔记（5）</title>
      <link href="post/ckh39g2ju000whwtlb1b7by41/"/>
      <url>post/ckh39g2ju000whwtlb1b7by41/</url>
      
        <content type="html"><![CDATA[<p>异步这个话题可以说是面试必问的，有些公司只问异步，异步搞不清楚直接死翘翘。所以我还是。。。整理一下吧，不然总忘，之前为了应付面试刷过很多异步的题，但都有背的成分，这样不好！</p><p>我们首先要明确一个问题，“执行”这个事情一个巴掌拍不响，需要我们和 JS 引擎一起来配合。</p><p>所以我们需要确立一个感性的认知：<strong>一个 JS 引擎会常驻于内存中，它等待着宿主（也就是我们）把 JS 代码或者函数传递给它执行。</strong></p><p>早起版本中，我们只是一个“翻译”，我们把指令翻译成代码，排好执行顺序，塞给引擎，引擎开始做执行。但是 ES5 之后，JS 引擎自己也可以发起任务了。</p><p>因此，我们把<strong>宿主发起的任务成为宏任务，JS 引擎发起的任务成为微观任务</strong>。</p><h2 id="宏任务与微观任务"><a href="#宏任务与微观任务" class="headerlink" title="宏任务与微观任务"></a>宏任务与微观任务</h2><p>我们说到宏任务就是由宿主发起的任务，那么作为 JS 引擎，在宏观任务层面，它的工作就行“等待-执行-等待-执行-…”，这种工作模式在 Node 中被称为“事件循环”。</p><blockquote><p>每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。</p></blockquote><p>我们王深进一步，我们来分析一下单个的宏观任务。以 <code>promise</code> 为例，由于 <code>promise</code> 代码是会产生异步的，所以每个宏观任务列表中又会包含一个微观任务列表。</p><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-5/1.jpg"></p><p>由于 JS 是单线程，所以这里的宏观任务队列只能顺着来，那下一个宏观任务执行的条件是上一个宏观任务执行完毕，包括上一个宏观任务中包含的所有微观任务。</p><p>清楚了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了。例如：<code>promise</code> 永远的在当前宏观任务队列中的微观任务尾部去添加一个微观任务，也就是说 <code>promise</code> 添加的任务在当前宏观任务里是最后执行的；<code>setTimeout</code> 等宿主 API，则会添加到宏观任务队列里。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我们总说 JS 是单线程语言，比较起其他语言来说总觉得单薄了一点，毕竟 10 天创建的语言，要求不要太高了。况且本身 JS 创造的时候就是给浏览器用的，要是多线程的话，A 线程创建一个 DOM，B 线程删除这个 DOM，你说让浏览器听谁的。所以说它只能单线程。</p><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p><code>Promise</code> 是 JS 提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。</p><p>通俗理解就像是双十一店铺给了优惠券，至于这个优惠券啥时候用，你自己觉得，店铺不会催你。这里的优惠券就是“承诺”。</p><p><code>promise</code> 有两个明显特征：</p><ol><li><strong>对象的状态不受外界影响</strong>。<code>promise</code> 有三种状态：<code>pending</code>、<code>fulfiled</code>、<code>rejected</code>，只有异步操作的结果可以决定当前是哪种状态，其他的任何操作都没办法改变状态。</li><li><strong>状态一旦改变了，就不会在变</strong>。初始状态肯定是 <code>pending</code>，但是一旦成功或失败了，无论你怎么兑现承诺，结果都是一样的。</li></ol><p>虽说 <code>promise</code> 改革了异步的解决方案，但是它有一个问题就是没办法取消，一建立就会立即执行，没办法中途取消。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> sleep <span class="token operator">=</span> time <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>单独的 <code>promise</code> 我们还是比较清楚怎么执行的，但是一旦上升到宏观任务层面就有点抓狂。我们一点一点增加难度。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">reolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1  3  2</span></code></pre><p>这里的执行顺序是 1 3 2， winter 在文章中讲到是在执行 3 之前，我们已经拿到了 <code>promise</code> 的结果，但是因为 <code>reolve</code> 始终是个异步操作，所以要等到 3 之后。从宏观任务的角度来理解是不是可以说，整段代码是宿主（我们）给到引擎的，引擎自发的发起了 <code>resolve</code> 任务，那么整段代码就是一个宏观任务，<code>reolve</code> 作为该宏观任务中的微观任务要最后执行？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">reolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1 4 3 2</span></code></pre><p>我们依旧用宏观任务和微任务理论来解释，这个时候相比较上面多了 <code>setTimeout</code>，我们之前提到过，<code>setTimeout</code> 是浏览器 API，它产生了宏观任务，<code>Promise</code> 产生的是微观任务，所以我们可以理解为宏观任务队列中有两个宏观任务，一个宏观任务里面有一个微观任务队列，一个没有。根据顺序，我们要先执行有微观的那个。也就是说<strong>微任务始终先于宏任务</strong>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> begin <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 强制等一秒，想让 3 在 1 后面执行，毕竟一个是 1000，一个是 0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> begin <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 2 3 1</span></code></pre><p>我们是想让 3 放在 1 后面，但是执行出来还是 3 在 1 前面，这也证明了微任务先于宏任务。</p><p>既然明白了宏任务和微任务，我们来总结一下如何分析异步执行顺序：</p><ol><li>分析有多少个宏任务</li><li>在每个宏任务里面有多少个微任务</li><li>根据调用次序，确定宏任务中微任务的执行次序</li><li>根据宏任务的触发规则和调用次序，确定宏任务执行次序</li><li>确定整个顺序</li></ol><p>根据上面的总结，我们来看个🌰</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>首先我们确定一下有几个宏观任务。因为 <code>setTimeout</code> 产生的是宏观任务，所以整个代码被 <code>setTimeout</code> 分割成了两个宏观任务。一个是输出 1 2 ，一个是 <code>setTimeout</code>。</p><p>其次我们看看有没有围观任务任务，<code>setTimeout</code> 里面有一个微观任务，因为里面执行了 <code>resolve</code>。</p><p>再者我们确定调用次序，先执行第一个宏观任务，输出 2 1，执行第二个宏观任务，等了 5 秒，执行了 <code>resolve</code> 里面的 3。</p><p>所以我们需要把握一个点：分割宏观任务的不是 <code>promise</code>，而是 <code>setTimeout</code>。</p><p>至于 <code>promise</code> 的一些属性和方法可以看看阮一峰老师的 <a href="https://es6.ruanyifeng.com/#docs/promise">ES6 入门</a>。</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async 函数必定返回 Promise，我们可以把所有返回 Promise 的函数都称为异步函数。</p><p>async 比较特殊，需要在 <code>function</code> 关键字前面加上 async，这样就算是定义了，可以在这个函数内部使用 await 来等一个 Promise。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>async 函数支持嵌套的，这样看起来就和我们想象中的执行顺序一样了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo1</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token string">'Bonnie'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><a href="https://es6.ruanyifeng.com/#docs/async">阮一峰老师讲的 async/await</a></p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>要求: 我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 执行时 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端笔记（4）</title>
      <link href="post/ckh39g2jt000uhwtlflw76vcr/"/>
      <url>post/ckh39g2jt000uhwtlflw76vcr/</url>
      
        <content type="html"><![CDATA[<p>对于原型以及它相关的一系列知识我一直都有点搞不清楚。这里我会结合<a href="https://time.geekbang.org/column/article/79539">《重学前端》</a>和<a href="https://github.com/mqyqingfeng/Blog/issues/2">《深入系列》</a> 来梳理一下这部分知识点。</p><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>winter 在文章中举了一个🌰我觉得特别形象的说明了啥是原型。</p><blockquote><p>照猫画虎</p></blockquote><p>这里的“猫”就是“虎”的原型</p><h2 id="Javascript-的原型"><a href="#Javascript-的原型" class="headerlink" title="Javascript 的原型"></a>Javascript 的原型</h2><p>原型系统的特征：</p><ul><li>如果所有对象都有私有字段<code>prototype</code>，就是对象的原型</li><li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止</li></ul><p>既然我们知道了原型是什么，那我们能不能操作原型呢？答案是可以的，ES6 给我们提供了三个内置函数，用来直接访问操纵原型。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create(obj)</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf(obj)</code></a></li><li><a href=""><code>Object.setPrototypeOf(obj, prototype)</code></a></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> cat <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'meow~'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'jump'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> tiger <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">,</span> <span class="token punctuation">{</span>    say<span class="token punctuation">:</span> <span class="token punctuation">{</span>        writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        value<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'roar!'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">let</span> anotherCat <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>anotherCat<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// meow</span>anotherCat<span class="token punctuation">.</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// jump</span><span class="token keyword">let</span> anotherTiger <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>tiger<span class="token punctuation">)</span>anotherTiger<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// roar</span>anotherTiger<span class="token punctuation">.</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// jump</span></code></pre><p>这里我们首先创建了一个 <code>cat</code>，它有两个方法。接着我们基于 <code>cat</code> 为原型创建了 <code>tiger</code>，并且做了些更改。我们创建两个变量，分别以 <code>cat</code> 和 <code>tiger</code> 为原型创建出来。</p><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><h3 id="早期版本中的类和原型"><a href="#早期版本中的类和原型" class="headerlink" title="早期版本中的类和原型"></a>早期版本中的类和原型</h3><p>在早期版本中，类的定义是**一个私有属性<code>class</code>**，我们想要访问 <code>class</code> 只有一个方法，<code>Object.prototype.toString.call(obj)</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span>  <span class="token comment" spellcheck="true">// [object Object]</span><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span>  <span class="token comment" spellcheck="true">// [object Number]</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span>  <span class="token comment" spellcheck="true">// [object String]</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span>  <span class="token comment" spellcheck="true">// [object Boolean]</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span>  <span class="token comment" spellcheck="true">// [object Date]</span><span class="token keyword">var</span> arg <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> arguments <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// [object Arguments]</span><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span> <span class="token comment" spellcheck="true">// [object RegExp]</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span> <span class="token comment" spellcheck="true">// [object Function]</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">// [object Array]</span><span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span> <span class="token comment" spellcheck="true">// [object Error]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>o<span class="token punctuation">,</span> n<span class="token punctuation">,</span> s<span class="token punctuation">,</span> b<span class="token punctuation">,</span> d<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> r<span class="token punctuation">,</span> f<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> e<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>v <span class="token operator">=</span><span class="token operator">></span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>判断数组中也有用到这个方法</strong></p><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><p>从 ES5 开始，私有属性 <code>class</code> 被 <code>Symbol.toStringTag</code> 代替。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'MyObj'</span><span class="token punctuation">}</span>o <span class="token operator">+</span> <span class="token string">''</span>  <span class="token comment" spellcheck="true">// [object MyObj]</span></code></pre><p>这里最后输出的时候加了空字符串相当于调用 <code>Object.toString()</code> 方法。</p><p>这里需要提到一个关键知识点，<code>new</code> 关键字。</p><p><strong><code>new</code> 运算接受一个构造器和一组调用参数，实际上做了几件事情：</strong></p><ol><li>以构造函数的 <code>prototype</code> 属性为原型，创建新的对象</li><li>将 <code>this</code> 和调用参数传给构造函数，执行</li><li>如果构造函数返回的是对象，就直接返回。否则返回第一步创建的对象</li></ol><p>用构造函数模拟类：</p><ul><li><p>在构造函数中添加属性（直接在构造函数中改 <code>this</code>）</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Alice'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>greet <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I'm </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// I;m Alice</span></code></pre></li><li><p>在构造函数的 prototype 属性上添加属（修改 <code>prototype</code> 指向的对象）</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Alice'</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>greet <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I'm </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// I;m Alice</span></code></pre></li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6 中引入了 <code>Class</code> 来创建类，这也是我最喜欢的创建类的方式，虽然在运行时它和老版本没有区别。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">}</span>    <span class="token keyword">get</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">12</span>    <span class="token punctuation">}</span>    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I'm </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 继承</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// I'm Alice</span></code></pre><h2 id="相关字段解析"><a href="#相关字段解析" class="headerlink" title="相关字段解析"></a>相关字段解析</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h3><p>我们在上文中提到原型系统特种中</p><blockquote><p>如果所有对象都有私有字段<code>prototype</code>，就是对象的原型</p></blockquote><p>那么这个 <code>prototype</code> 究竟指向谁呢，可以这么理解。<code>prototype</code> 指向一个对象，这个对象就是<strong>调用该构造函数而创建的实例的原型</strong>，也就是说实例的<strong>原型</strong>不是构造函数，是与构造函数关联的一个对象，这个对象身上有一些属性什么的。</p><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-4/prototype1.jpg"></p><p>我们简单点理解这张图，话说 <code>Person</code> 我们知道是一个函数，函数的本质就是对象，所以我们可以把 <code>Person</code> 看作一个对象。<code>Person.prototype</code> 是语言自动给我关联的一个对象，这个对象身上有一些属性或者方法，由于是语言自动关联的，我们不知道叫啥，所以一般用 <code>Person.prototype</code> 来表示，当然为了方便记忆，也可以随便给起个名，我就叫无名氏吧。</p><p>所以之后我们表示原型的时候可以用 <code>构造函数.prototype</code> 来表示，毕竟 <code>Person</code> 的 <code>prototype</code> 指向的就是实例的原型。</p><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>上文提到了实例，我们先明确实例是啥。实例就是 <code>new</code> 出来的那个对象。</p><p>我们知道 <code>Person.prototype</code> 是实例的原型，那实例和原型之间我们怎么表示呢？</p><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-4/prototype2.jpg"></p><p>每一个对象（除了 <code>null</code>）以为都有一个属性 <code>__proto__</code>，这个属性会指向该对象的原型，也就是图中的 <code>Person.prototype</code></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h3><p>上文说到有两种方法能够指向原型，那么从原型出发，有没有属性或方法可以指向构造函数和实例呢？</p><p>实例就别想了，毕竟实例可以有多个，怎们指的过来。</p><p>构造函数倒是有一个属性<code>constructor</code></p><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-4/prototype3.jpg"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><blockquote><p>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止</p></blockquote><p>结合上面的图和原型系统的第二个特征，我们会想一个问题，原型的本质既然是对象，那么对象就有 <code>__proto__</code> 来指向该对象的原型，原型的原型是啥？什么时候为“空”？</p><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-4/prototype4.jpg"></p><p>从图中我们可以看到 <code>Person.prototype</code> 的原型是 <code>Object.prototype</code>，也就是 <code>Object</code> 关联的那个对象。那 <code>Object.prototype</code> 再找原型就是 <code>null</code>，这也就找到头了。</p><p>所以说原型链（蓝色线条）找到头就是 <code>null</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于原型和原型链的知识其实注意区分两个概念：</p><ul><li>构造函数部署原型</li><li>A 对象会自动关联一个 B 对象作为 A 实例的原型，B 对象长啥样以及叫啥都不知道，这个语言自己弄的，别管。想操作的时候就用 <code>Person.prototype</code> 来操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多种继承方式</title>
      <link href="post/ckh39g2jc0001hwtla0q4ebs6/"/>
      <url>post/ckh39g2jc0001hwtla0q4ebs6/</url>
      
        <content type="html"><![CDATA[<p>这是一篇笔记的笔记，偶然间在 github 发现了 <a href="https://github.com/mqyqingfeng/Blog">这个 repo</a>，其中深入系列还是不错的，至少讲的比较明白，适合我这样的孩子。把之前自己不太清楚的地方搞搞清楚。</p><p>本篇主要是整理一下多种继承方式，面试的时候总问到继承。在看继承之前还是推荐把原型和原型链搞搞清楚，不然看着有点晕。</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>最基本的继承，也是比较好理解的。宗旨就是 Child 的原型指向 Parent 的实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi~'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// parent</span>c<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Hi~</span></code></pre><p>这种继承方式会有两个很严重的问题：</p><ul><li>引用类型的值会被共享</li><li>在创建 Child 的实例（也就是 <code>new Child</code>）的时候不能向 Parent 传值</li></ul><p>我们先看第一个问题，注意说的是<strong>引用类型</strong>的值。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token string">'green'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'golden'</span>c<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// golden</span>c1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// golden</span></code></pre><p>按常理来说每一个实例应该都是独立的，与其它实例互不干涉，但是在原型链继承中引用值类型是被共用的。顺着我们看第二个问题，就算是 <code>new Child</code> 的时候传值了，怎么给 Parent 是不是个问题。</p><h2 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h2><p>通过 <code>call</code> 或者 <code>apply</code> 把 Parent 放在 Child 里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Eva'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'pink'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true">// Eva</span>c<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ['pink', 'green']</span></code></pre><p>我们来看看有没有解决原型链继承的两个问题：引用类型值被共享；不能传参。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Eva'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'pink'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'blue'</span>c<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ["blue", "green"]</span>c1<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ["pink", "green"]</span></code></pre><p>看来共享的问题解决了，保证了每个 Child 实例都是独立的。</p><p>传参问题也是 OK 的，毕竟 <code>call()</code> 和 <code>apply()</code> 是可以接收参数的，只是接受方式不太一样。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span><span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Eva'</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true">// Alice</span>c1<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// Eva</span></code></pre><p>不过缺点是方法是在构造函数中定义的，导致每次创建实例都会创建一遍方法。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>原型链继承 + 构造函数继承</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I\'m </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构造函数继承</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 原型链继承</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/** * 这里需要注意一个事情 * 当我们将原型指到 Parent 的实例身上，那么 Child 的原型指向的构造函数就变成了 Parent * 这是原型链继承的副作用 * 我们需要指回来 **/</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span>c1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// I'm Alice</span></code></pre><p>这种继承方式的优点在于解决了传参问题和引用类型值的共享问题。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span><span class="token keyword">let</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Bonnie'</span><span class="token punctuation">)</span>c1<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'pink'</span>c1<span class="token punctuation">.</span>colors  <span class="token comment" spellcheck="true">// ['pink', 'green']</span>c2<span class="token punctuation">.</span>colors <span class="token comment" spellcheck="true">// ['blue', 'green']</span></code></pre><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>将传入的对象作为创建的对象的原型。</p><p>其实特别像是“引擎自动关联一个对象给你”一样，只是这里我们手动关联。</p><p><strong>这也是 <code>Object.create()</code> 的模拟实现</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Bonnie'</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><p>它的问题在于引用类型会被共享</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    colors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Bonnie'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>o1<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'User'</span>o2<span class="token punctuation">.</span>colors <span class="token comment" spellcheck="true">// ['User']</span></code></pre><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>    clone<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi~'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> clone<span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><p>这种继承方式的问题在于</p><ul><li>引用值类型共享</li><li>每次创建都会创建一遍方法，这一点和经典继承一样</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>    clone<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi~'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> clone<span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    colors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Bonnie'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>o1<span class="token punctuation">.</span>colors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'User'</span>o2<span class="token punctuation">.</span>colors <span class="token comment" spellcheck="true">// ['User']</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JS 混淆知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端（3）</title>
      <link href="post/ckh39g2jt000thwtldms7alir/"/>
      <url>post/ckh39g2jt000thwtldms7alir/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向对象还是基于对象？</p></blockquote><h2 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h2><h3 id="唯一标识：即使完全相同的两个对象，也并非同一个对象"><a href="#唯一标识：即使完全相同的两个对象，也并非同一个对象" class="headerlink" title="唯一标识：即使完全相同的两个对象，也并非同一个对象"></a>唯一标识：即使完全相同的两个对象，也并非同一个对象</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>a <span class="token operator">==</span> b <span class="token comment" spellcheck="true">// false</span></code></pre><p>对象具有唯一标识的<strong>内存地址</strong>，所以具有唯一标识。</p><h3 id="状态：对象具有状态，同一对象可能处于不同状态"><a href="#状态：对象具有状态，同一对象可能处于不同状态" class="headerlink" title="状态：对象具有状态，同一对象可能处于不同状态"></a>状态：对象具有状态，同一对象可能处于不同状态</h3><p>在 JS 中，将<strong>状态</strong>和<strong>行为</strong>统一抽象为<strong>属性</strong>，所以和第三点行为一起说。</p><h3 id="行为：对象的状态可能因为它的行为产生变迁"><a href="#行为：对象的状态可能因为它的行为产生变迁" class="headerlink" title="行为：对象的状态可能因为它的行为产生变迁"></a>行为：对象的状态可能因为它的行为产生变迁</h3><p>由于 JS 把行为和状态统一抽象为属性，所以属性的方式就可以有数据或函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token string">'Hi~'</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="对象的两类属性"><a href="#对象的两类属性" class="headerlink" title="对象的两类属性"></a>对象的两类属性</h2><p>JS 用一组特征（attribute）来描述属性（property）</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>特征：</p><ul><li>value</li><li>writable：默认为 <code>true</code></li><li>enumerable：默认为 <code>true</code></li><li>configurable：默认为 <code>true</code></li></ul><p>想要查看某一属性的配置的话，可以用到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor(obj, key)</code></a> 查看</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { value: 123, writable: true, enumerable: true, configurable: true }</span></code></pre><p>如果想要更改的话就用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty(obj, key, config)</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token keyword">let</span> config <span class="token operator">=</span> <span class="token punctuation">{</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span></code></pre><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>特征</p><ul><li>getter</li><li>setter</li><li>enumerable</li><li>configurable</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><blockquote><p>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端笔记（2）</title>
      <link href="post/ckh39g2jl0007hwtl18s71lim/"/>
      <url>post/ckh39g2jl0007hwtl18s71lim/</url>
      
        <content type="html"><![CDATA[<p>今天主要是讲类型，面试中经常会问到判断类型的问题，所以除了文章中讲到的知识点之外可能还会有一些补充吧。</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>String</li><li>Number</li><li>Symbol</li><li>Object</li></ul><h2 id="Undefined-amp-Null"><a href="#Undefined-amp-Null" class="headerlink" title="Undefined &amp; Null"></a>Undefined &amp; Null</h2><blockquote><p>为什么有的编程规范要求用 void 0 代替 undefined？</p></blockquote><p>我们先来解释一下 <code>void</code> 运算符，该运算符对给定的表达式进行求值，然后返回 <code>undefined</code>。Undefined 表示未定义的，所有变量的初始类型都是 Undefined，该类型只有一个值 <code>undefined</code>。</p><p>这里说 <code>void 0</code> 去代替 <code>undefined</code> 是因为 <code>undefined</code> 不是 JS 中的关键字，他是一个变量，作为变量来说，就有可能被篡改，我可以直接 <code>undefined = 123</code>，也是为了保证在逻辑代码中不要出现这种 *** 问题，有的规范会要求用 <code>void 0</code> 来代替 <code>undefined</code>。</p><p>这里其实有一个常见问题就是如何判断一个值是 <code>undefined</code>，毕竟这孩子是能被篡改的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> ii <span class="token operator">===</span> undefined  <span class="token comment" spellcheck="true">// true</span><span class="token keyword">typeof</span> i <span class="token operator">==</span> <span class="token string">'undefined'</span>  <span class="token comment" spellcheck="true">//true</span></code></pre><p>上面提到了 Undefined ，就一定要说说 Null，这俩孩子就好像是绑在一起的，面试的时候总会问到。</p><p>Null 表示空，而且它是个关键字，不用担心篡改的问题。不过需要注意的是 <code>null == undefined</code> 是 <code>true</code> ，需要用 <code>===</code></p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>注意强制转为会转成 <code>false</code> 的值</p><ul><li><code>false</code></li><li><code>0</code></li><li><code>-0</code></li><li><code>''</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>NaN</code></li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote><p>字符串有最大长度吗？</p></blockquote><p>有最大长度是肯定有的，但是这个长度不是我们平常意义上的多少个字，而是 UTF16 编码长度，最大长度为 <strong>2^53 - 1</strong></p><p>需要注意的是字符串一定构造出来，就没有方法能够变更。这也就是我们更改字符串的时候为什么会先拆再组合。</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 中有几个特例需要注意一下 <code>NaN</code>、<code>+0</code>、<code>-0</code>、<code>Infinity</code>、<code>-Infinity</code>。</p><p><code>-0</code> 在平常工作中也没有太注意过，但是文章中有提到需要留意区分，照例还是安排一下。</p><blockquote><p>另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。</p></blockquote><p>我们回到文章中提到的经典迷惑题</p><blockquote><p>0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？</p></blockquote><p>这里需要把握两个知识点</p><ol><li>在 JS 中，Number 是<strong>双精度浮点数规则</strong>，所以加起来是 0.30000…，浮点数运算的精度问题导致等式左右的结果不想等，差的很小。</li><li>比较方法也有锅，我们不能用 <code>==</code> 或 <code>===</code> 来比较，我们应该比较两者的最小精度是不是小于 JS 提供的最小精度值</li></ol><pre class=" language-javascript"><code class="language-javascript">Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span>EPSILON</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>这是 ES6 中引入的新类型。在 ES5 中对象的 key 都是字符串，这就会导致同名的会有覆盖行为。为了保证每个属性的 key 都是唯一的，ES6 引入了 Symbol，它表示唯一的值。</p><p>由于 Symbol 生成的是原始类型值，不是对象，所以不能用 <code>new</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>a <span class="token operator">==</span> b  <span class="token comment" spellcheck="true">// false</span>a <span class="token operator">===</span> b <span class="token comment" spellcheck="true">// false</span></code></pre><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>这个类型涉及的知识点就比较多了，后面应该会拆开单独讲吧。</p><p>在 JS 中，对象的属性分为<strong>数据属性</strong>和<strong>属性访问器</strong>，对于 key 来说可以是字符串或者 Symbol</p><blockquote><p>为什么给对象添加的方法能用在基本类型上？</p></blockquote><p>答：运算符提供了装箱操作，它会根据基础类型构造一个临时对象，让我们能在基础类型上调用对应的对象方法。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>在文章中还涉及到了类型转换的装箱操作和封箱操作，说实话没怎么看懂，等我搞定了我再来更新！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学前端笔记（1）</title>
      <link href="post/ckh39g2jh0003hwtl8spuezhm/"/>
      <url>post/ckh39g2jh0003hwtl8spuezhm/</url>
      
        <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/intro/154">《重学前端》</a> 购买了很久，之前也断断续续的看了一些，一直没有很认真的学习。现在终于有时间沉下心来好好看看了。这个系列的笔记和原文对比起来可能有些不一样，因为我会看完一篇，加上自己的理解对整篇文章做一个回顾和总结，所以建议先看完对应的章节再看笔记。</p><h2 id="开篇词-从今天起，重新理解前端"><a href="#开篇词-从今天起，重新理解前端" class="headerlink" title="开篇词 | 从今天起，重新理解前端"></a>开篇词 | 从今天起，重新理解前端</h2><p>本篇首先介绍了前端的发展历史。青铜时期（ajax 出现）→ 白银时期（前端开始有意识的处理数据，保存数据，逐步与后端分离）→ 黄金时代（框架的出现）</p><p>其次介绍了《重学前端》的目的，作者会提供视角帮助读者系统的认识前端知识点，形成自己的知识图谱。将知识从点到面，逐步涵盖理解前端技能点。</p><h2 id="明确你的前端学习路线和方法"><a href="#明确你的前端学习路线和方法" class="headerlink" title="明确你的前端学习路线和方法"></a>明确你的前端学习路线和方法</h2><p>很多人都说前端门槛相当低，但是能一直向上走的人没几个。我个人认为门槛是低，但就是因为低，导致知识点庞大且杂乱。同样的效果通过不同属性都可以达到，但是根本上他们之间还有一定的却别。这让学习成本在不断的增加。前端技术的发展比任何一门语言发展的都快，无论是框架、库还是相关标准，变化之快是你想不到的，这在某种程度上无疑增加了前端工作者的学习成本。</p><p>面对这种「学习」环境，我们能做的就是找到适合自己的学习方法和学习路径。</p><p>winter 在文章中介绍了两种学习方法：<strong>建立知识架构</strong>和<strong>追本溯源</strong></p><h3 id="建立知识架构"><a href="#建立知识架构" class="headerlink" title="建立知识架构"></a>建立知识架构</h3><p>简单说来是就画自己的知识图谱，从父节点一层一层细化自己的子节点。</p><p>前端从大方向来分可以分为：HTML、CSS、JavaScript、浏览器、综合应用</p><p>我们以  JavaScript 为例一层一层细化节点</p><blockquote><p>因为对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程</p></blockquote><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/156d0524.png" alt="JavaScript 顶层分类"></p><h3 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h3><p>简单说就是「翻旧账」，去看论文、去看标准。虽然我觉得标准不是给人看的。</p><h2 id="列一份前端知识架构图"><a href="#列一份前端知识架构图" class="headerlink" title="列一份前端知识架构图"></a>列一份前端知识架构图</h2><p>根据上一篇的介绍，我们尝试的列一份知识图片</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/1ac20555.png" alt="JavaScript 知识架构"></p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/1d1d05a8.png" alt="HTML 知识架构"></p><p>对于 HTML 来说我们最直观的感受就是标签，那就按照标签的属性来划分。这个东西没有对错之分，只要符合划分原则就行。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/4abf7c12.png" alt="CSS 知识架构"></p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/03f35380.png" alt="浏览器知识架构"></p><h3 id="前端工程实践"><a href="#前端工程实践" class="headerlink" title="前端工程实践"></a>前端工程实践</h3><p><img src="/images/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-1/b1326b14.png" alt="前端工程实践"></p><p>对于这部分而言对于团队的意义会更重大一点</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 知识架构 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
